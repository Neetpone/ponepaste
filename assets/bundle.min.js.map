{"version":3,"file":"bundle.min.js","sources":["../js/tag_input.js","../js/main.js"],"sourcesContent":["function htmlToElement(html) {\n    const template = document.createElement('template');\n\n    template.innerHTML = html.trim();\n\n    return template.content.firstChild;\n}\n\nfunction escapeHtml(unsafe) {\n    return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\nclass TagsInput {\n    constructor(element, options = {}) {\n        this.element = element;\n        this.tags = [];\n        this.options = options\n\n        this.maxTags = options.maxTags || 10;\n        this.inputNode = null;\n        this.containerNode = null;\n    }\n\n    attach() {\n        this.element.style.display = 'none';\n\n        this.containerNode = htmlToElement('<div class=\"tags-input\"></div>');\n        this.inputNode = htmlToElement('<input class=\"input\" type=\"text\" placeholder=\"10 tags maximum\" value=\"\" />');\n        this.containerNode.appendChild(this.inputNode);\n\n        this.element.parentNode.insertBefore(this.containerNode, this.element.nextSibling);\n\n        /* Handle addition and removal of tags via key-presses */\n        this.containerNode.addEventListener('keydown', this._handleInputKeyUp.bind(this));\n\n        /* Handle deletions by clicking the delete button */\n        this.containerNode.addEventListener('click', this._handleContainerClick.bind(this));\n    }\n\n    detach() {\n        this.tags.clear();\n        this.containerNode.remove();\n        this.element.style.display = 'inline-block';\n    }\n\n    updateHiddenInputValue() {\n        this.element.value = this.tags.join(',');\n    }\n\n    deleteTagNode(node) {\n        this.tags.splice(this.tags.indexOf(node.dataset.value.toLowerCase()), 1);\n        node.remove();\n\n        /* Below the limit? Make sure the input is enabled. */\n        if (this.tags.length < this.maxTags) {\n            this.inputNode.disabled = false;\n        }\n    }\n\n    addTag(tagValue) {\n        tagValue = tagValue.trim();\n\n        /* Tag value is probably not empty and we don't already have the same tag. */\n        if (tagValue !== '' && this.tags.indexOf(tagValue.toLowerCase()) === -1) {\n            this.tags.push(tagValue.toLowerCase());\n\n            this.inputNode.parentNode.insertBefore(\n                htmlToElement('<span class=\"tag is-info\" data-value=\"' + escapeHtml(tagValue) + '\">' + escapeHtml(tagValue) + '<span class=\"delete is-small\" /></span>'),\n                this.inputNode\n            );\n\n            /* Too many tags, disable the input for now. */\n            if (this.tags.length >= this.maxTags) {\n                this.inputNode.disabled = true;\n            }\n        }\n    }\n\n    _handleInputKeyUp(evt) {\n        let tagValue = this.inputNode.value;\n\n        if (evt.key === 'Backspace' && tagValue === '') {\n            // Remove the child\n            if (this.inputNode.previousSibling) {\n                this.deleteTagNode(this.inputNode.previousSibling);\n\n                this.updateHiddenInputValue();\n            }\n        } else if (evt.key === ',') {\n            this.addTag(tagValue);\n\n            this.inputNode.value = ''\n            this.updateHiddenInputValue();\n\n            evt.preventDefault();\n        }\n    }\n\n    _handleContainerClick(evt) {\n        if (evt.target && evt.target.classList.contains('delete')) {\n            this.deleteTagNode(evt.target.closest('.tag'));\n            this.updateHiddenInputValue();\n        }\n    }\n}\n\nexport { TagsInput };","import  { TagsInput } from './tag_input';\n\nclass Meme {\n    constructor() {\n        alert('xss');\n    }\n\n    meme() {\n        console.log('meme');\n    }\n}\n\nconst meme = new Meme();\n\nmeme.meme();\n\nnew TagsInput(null);"],"names":["htmlToElement","html","template","document","createElement","innerHTML","trim","content","firstChild","escapeHtml","unsafe","replace","TagsInput","element","options","tags","maxTags","inputNode","containerNode","style","display","appendChild","this","parentNode","insertBefore","nextSibling","addEventListener","_handleInputKeyUp","bind","_handleContainerClick","clear","remove","value","join","node","splice","indexOf","dataset","toLowerCase","length","disabled","tagValue","push","evt","key","previousSibling","deleteTagNode","updateHiddenInputValue","addTag","preventDefault","target","classList","contains","closest","alert","console","log","meme"],"mappings":"6TAAA,SAASA,EAAcC,OACbC,EAAWC,SAASC,cAAc,mBAExCF,EAASG,UAAYJ,EAAKK,OAEnBJ,EAASK,QAAQC,WAG5B,SAASC,EAAWC,UACTA,EACFC,QAAQ,KAAM,SACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,cAGjBC,wBACUC,OAASC,yDAAU,kBACtBD,QAAUA,OACVE,KAAO,QACPD,QAAUA,OAEVE,QAAUF,EAAQE,SAAW,QAC7BC,UAAY,UACZC,cAAgB,qCAGzB,gBACSL,QAAQM,MAAMC,QAAU,YAExBF,cAAgBlB,EAAc,uCAC9BiB,UAAYjB,EAAc,mFAC1BkB,cAAcG,YAAYC,KAAKL,gBAE/BJ,QAAQU,WAAWC,aAAaF,KAAKJ,cAAeI,KAAKT,QAAQY,kBAGjEP,cAAcQ,iBAAiB,UAAWJ,KAAKK,kBAAkBC,KAAKN,YAGtEJ,cAAcQ,iBAAiB,QAASJ,KAAKO,sBAAsBD,KAAKN,6BAGjF,gBACSP,KAAKe,aACLZ,cAAca,cACdlB,QAAQM,MAAMC,QAAU,qDAGjC,gBACSP,QAAQmB,MAAQV,KAAKP,KAAKkB,KAAK,kCAGxC,SAAcC,QACLnB,KAAKoB,OAAOb,KAAKP,KAAKqB,QAAQF,EAAKG,QAAQL,MAAMM,eAAgB,GACtEJ,EAAKH,SAGDT,KAAKP,KAAKwB,OAASjB,KAAKN,eACnBC,UAAUuB,UAAW,yBAIlC,SAAOC,GAIc,MAHjBA,EAAWA,EAASnC,UAGkD,IAA/CgB,KAAKP,KAAKqB,QAAQK,EAASH,sBACzCvB,KAAK2B,KAAKD,EAASH,oBAEnBrB,UAAUM,WAAWC,aACtBxB,EAAc,yCAA2CS,EAAWgC,GAAY,KAAOhC,EAAWgC,GAAY,2CAC9GnB,KAAKL,WAILK,KAAKP,KAAKwB,QAAUjB,KAAKN,eACpBC,UAAUuB,UAAW,qCAKtC,SAAkBG,OACVF,EAAWnB,KAAKL,UAAUe,MAEd,cAAZW,EAAIC,KAAoC,KAAbH,EAEvBnB,KAAKL,UAAU4B,uBACVC,cAAcxB,KAAKL,UAAU4B,sBAE7BE,0BAEU,MAAZJ,EAAIC,WACNI,OAAOP,QAEPxB,UAAUe,MAAQ,QAClBe,yBAELJ,EAAIM,uDAIZ,SAAsBN,GACdA,EAAIO,QAAUP,EAAIO,OAAOC,UAAUC,SAAS,iBACvCN,cAAcH,EAAIO,OAAOG,QAAQ,cACjCN,oCC9FJ,sCARLO,MAAM,qCAGV,WACIC,QAAQC,IAAI,mBAMfC,OAEL,IAAI7C,EAAU"}